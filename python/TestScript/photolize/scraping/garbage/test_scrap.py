# data属性による指定＋HTMLから一致する要素を取得し保存
# Generated by Selenium IDE
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.chrome.options import Options
import time
from bs4 import BeautifulSoup
import re
import regex
from selenium.webdriver.common.keys import Keys
import json
import os
from datetime import datetime
import difflib
import subprocess

import requests

class TestScrap():
  def setup_method(self, method):
    options = Options()
    # options.add_argument('--headless')  # ヘッドレスモードでブラウザを起動
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    self.driver = webdriver.Remote(command_executor='http://chrome:4444/wd/hub', options=options)
    self.driver.implicitly_wait(10) # 10秒まで待機する
    self.vars = {}
  
  def teardown_method(self, method):
    self.driver.quit()
  
  def test_addNewRecord(self):
    # photolizeにログインする
    self.driver.get("https://saruya:saruya@staging-user.photolize.jp/login/basic_auth")
    self.driver.get("https://staging-user.photolize.jp/login")
    self.driver.set_window_size(1463, 1032)
    self.driver.find_element(By.ID, "input-7").click()
    self.driver.find_element(By.ID, "input-7").send_keys("company_code26")
    self.driver.find_element(By.CSS_SELECTOR, ".v-btn__content").click()
    self.driver.find_element(By.ID, "input-11").send_keys("aridome")
    self.driver.find_element(By.ID, "input-14").send_keys("aridome")
    self.driver.find_element(By.CSS_SELECTOR, ".btn > .v-btn__content").click()

    ## 有留アプリテストを選択
    # 直接飛ぶ
    self.driver.get("https://staging-user.photolize.jp/appli/index?app_id=151")
    # 新規レコードの編集を選択
    self.driver.find_element(By.XPATH, "/html/body/div/div[2]/div/div[2]/div/div[2]/div[2]/div[2]/div/div[1]/div[2]/div[3]/div[2]/div/div/div[1]/div[1]/div/a/span/i").click()

    # # 現在いるページのURLを取得
    # current_url = self.driver.current_url
    # response = requests.get(current_url)
    # html_content = response.content
    # # BeautifulSoupを使用してDOMを解析
    # soup = BeautifulSoup(html_content, 'lxml')
    # # DOMツリーを描画
    # print_tree(soup)

    # # ラベルの入力欄を選択
    # element = self.driver.find_element(By.XPATH, "/html/body/div/div[2]/div[1]/main/div/div[2]/div/div/div[3]/div[10]/div[1]")
    # element.click()

    # # 少し待つ
    # time.sleep(1)

    # HTMLデータからbody部分を取得
    page_source = self.driver.page_source

    # BeautifulSoupを使ってbody部分のみを抽出
    soup = BeautifulSoup(page_source, 'html.parser')
    body_content = soup.body

    # テキストが "テスト" である要素を取得
    target_divs = soup.find_all('div', string='あ')

    # 取得した各要素に対して処理を行う例
    for target_div in target_divs:
        # 親の div 要素のクラス属性を取得
        class_value = target_div.parent.get('class')
        print("クラス属性の値:", class_value)

    # # 必要な要素を取得
    # target_div = body_content.find('div', class_='disp-wrap input flex_s_s fontsize5')

    # # 取得した要素が存在するか確認
    # if target_div:
    #     # テキストを取得
    #     text_content = target_div.text.strip()
    #     print("クラス flex_s_s fontsize5 のテキスト:", text_content)
    # else:
    #     print("指定したクラスの要素は存在しません")

    # # <div>要素内のすべての<input>タグを取得
    # input_elements_in_div = body_content.select('div input')

    # # 取得した要素に対して処理を行う例
    # for input_element in input_elements_in_div:
    #     print("input要素:", input_element)

    #     # input要素の属性や値を取得
    #     input_type = input_element.get('type')
    #     input_name = input_element.get('name')
    #     input_value = input_element.get('value')

    #     print(f"Type属性: {input_type}, Name属性: {input_name}, Value属性: {input_value}")

    # # ランダムなクラス名を持つ要素を取得
    # random_class_element = body_content.find(class_=True)

    # # 複数のクラスを持つ要素を取得
    # div_elements = body_content.find_all('div')

    # # 取得した要素に対して処理を行う例
    # for div_element in div_elements:
        # print("div要素:", div_element)
    # # 特定の条件に一致する<div>要素を取得
    # pattern = regex.compile(r'[\p{Script=Hiragana}\p{Script=Katakana}\p{Script=Han}\p{Z}ー、。，。]', regex.UNICODE) # regex.compile関数と\p{Z}を使う

    # # <div>要素内のテキストを検索
    # div_elements = body_content.find_all('div', string=pattern)

    # # 取得したdiv要素を出力
    # for div in div_elements:
    #     print(div.text)

        # # スタイル情報を取得
        # style_attribute = div_element.get('style')
        # if style_attribute:
        #     print("div要素:", div_element)
        #     print("Style属性の値:", style_attribute)

    # # 取得した要素に対して処理を行う例
    # for element in elements_with_classes:
    #     class_values = element.get('div')

    #     # スタイル情報を取得
    #     style_attribute = element.get('style')
    #     if style_attribute:
    #         print("div属性の値:", class_values)
    #         print("Style属性の値:", style_attribute)

    # # 取得した要素が存在する場合、テキストを表示
    # if random_class_element:
    #     print("------------------------------")
    #     # 取得した要素が存在する場合、class 属性の値を表示
    #     class_value = random_class_element.get('class')
    #     print("Class属性の値:", class_value)

    #     # # 対象の要素を取得
    #     # element = self.driver.find_element_by_class_name('v-btn__content')

    #     # スタイル情報を取得
    #     style_attribute = random_class_element.get_attribute('style')
    #     print("Style属性の値:", style_attribute)

    #     # スタイル情報を解析
    #     style_dict = {}
    #     for declaration in style_attribute.split(';'):
    #         if ':' in declaration:
    #             prop, value = declaration.split(':')
    #             style_dict[prop.strip()] = value.strip()

    #     # フォントサイズを表示
    #     font_size = style_dict.get('font-size', 'N/A')
    #     print(f'フォントサイズ: {font_size}')
    #     print("------------------------------")

    # # 特定の条件に一致する<div>要素を取得
    # pattern = regex.compile(r'[\p{Script=Hiragana}\p{Script=Katakana}\p{Script=Han}\p{Z}ー、。，。]', regex.UNICODE) # regex.compile関数と\p{Z}を使う

    # # <div>要素内のテキストを検索
    # div_elements = body_content.find_all('div', string=pattern)

    # # 取得したdiv要素を出力
    # for div in div_elements:
    #     print(div.text)

    # 画面を閉じる
    self.driver.close()

def print_tree(element, indent=0):
    print('  ' * indent + element.name)
    for child in element.find_all(recursive=False):
        print_tree(child, indent + 1)

def get_id_from_body(self, keyWord):
  ### HTMLのbody部分から一致した要素をtxtファイルに出力する ###

  # ページソースを取得
  page_source = self.driver.page_source

  # BeautifulSoupを使ってbody部分のみを抽出
  soup = BeautifulSoup(page_source, 'html.parser')
  body_content = soup.body

  # 特定のclass属性を持つdiv要素を取得
  div_elements = body_content.find_all('div', class_='my-div')

  # 取得したdiv要素を出力
  for div in div_elements:
      print(div.text)

  # 正規表現オブジェクトを作成
  pattern = re.compile(keyWord)

  # bodyから正規表現に一致するテキストを含む要素をすべて取得
  matches = body_content.find_all(name=pattern)

  # 一致する要素を取得できたかどうかで異なる処理を行う
  if matches: # 取得できた場合
      print("一致する要素が見つかりました")
      # 一致する要素をtxtファイルに保存
      save_matching_elements_to_txt(matches)
      # 一致する要素をjsonファイルに保存
      save_matching_elements_to_json(matches)
      return
  else: # 取得できなかった場合
      print("一致する要素が見つかりませんでした")
  
def save_matching_elements_to_txt(matches):
  ### 一致した要素をtxtファイルに出力する ###

  # 保存先ディレクトリを指定
  output_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "txt/")
  # フォルダが存在しない場合は作成
  if not os.path.exists(output_dir):
      os.makedirs(output_dir)
      command = f"sudo chown -R aridome:aridome {output_dir}"
      # コマンドを実行
      subprocess.call(command, shell=True)
      
  # 現在の日付を取得してフォーマット
  current_date = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
  # ファイル名を生成
  output_file_name = f"matching_elements_{current_date}.txt"
  
  # txtファイルに出力
  output_file_path = os.path.join(output_dir, output_file_name)
  with open(output_file_path, 'w', encoding='utf-8') as f:
      for match in matches:
          f.write(str(match) + '\n')
  
  print(f"一致した要素を{output_file_path}に保存しました")
  return output_file_path

def save_matching_elements_to_json(matches):
  ### 一致した要素をjsonファイルに出力する ###

  # 保存先ディレクトリを指定
  output_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "json/")
  # フォルダが存在しない場合は作成
  if not os.path.exists(output_dir):
      os.makedirs(output_dir)
      command = f"sudo chown -R aridome:aridome {output_dir}"
      # コマンドを実行
      subprocess.call(command, shell=True)

  # 現在の日付を取得してフォーマット
  current_date = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
  # ファイル名を生成
  output_file_name = f"matching_elements_{current_date}.json"

  # 一致する要素をリストに格納
  matching_elements = []
  for match in matches:
      matching_elements.append(str(match))
  
  # JSONファイルに出力
  output_file_path = os.path.join(output_dir, output_file_name)
  with open(output_file_path, 'w', encoding='utf-8') as f:
      json.dump(matching_elements, f, ensure_ascii=False, indent=4)
  
  print(f"一致する要素を{output_file_path}に保存しました")

def save_html_data(file_name, html_data):
  ### HTMLデータをhtmlファイルに出力する ###

  # 保存先ディレクトリを指定
  output_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "html_data/")
  # フォルダが存在しない場合は作成
  if not os.path.exists(output_dir):
      os.makedirs(output_dir)
      command = f"sudo chown -R aridome:aridome {output_dir}"
      # コマンドを実行
      subprocess.call(command, shell=True)
      
  # 現在の日付を取得してフォーマット
  current_date = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
  # ファイル名を生成
  output_file_name = f"{file_name}_{current_date}.html"
  
  # ファイルにHTMLデータを出力
  output_file_path = os.path.join(output_dir, output_file_name)
  with open(output_file_path, "w", encoding="utf-8") as f:
      f.write(html_data)

  print(f"HTMLデータを{output_file_path}に保存しました")

def save_diff_html_data(html_data_file, html_data_file_2):
  ### ２つのHTMLデータの差分をtxtファイルに出力する ###

  # 保存先ディレクトリを指定
  output_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "html_diff/")
  # フォルダが存在しない場合は作成
  if not os.path.exists(output_dir):
      os.makedirs(output_dir)
      command = f"sudo chown -R aridome:aridome {output_dir}"
      # コマンドを実行
      subprocess.call(command, shell=True)

  # 現在の日付を取得してフォーマット
  current_date = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
  # ファイル名を生成
  output_file_name = f"diff_{current_date}.txt"

  # 差異を別ファイルに出力
  differ = difflib.Differ()
  diff = differ.compare(html_data_file.splitlines(), html_data_file_2.splitlines())

  output_file_path = os.path.join(output_dir, output_file_name)
  with open(output_file_path, "w", encoding="utf-8") as f:
      f.write("\n".join(diff))

  print(f"2つのHTMLデータの差異を{output_file_path}に保存しました")

def save_diff_id(txt_file_path, txt_file_path_2):
  ### 2つのHTMLテキストデータの差分をtxtファイルに出力する ###

  # 保存先ディレクトリを指定
  output_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "diff_id/")
  # フォルダが存在しない場合は作成
  if not os.path.exists(output_dir):
      os.makedirs(output_dir)
      command = f"sudo chown -R aridome:aridome {output_dir}"
      # コマンドを実行
      subprocess.call(command, shell=True)

  # 現在の日付を取得してフォーマット
  current_date = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
  # ファイル名を生成
  output_file_name = f"diff_id_{current_date}.txt"

  # ファイルを読み込んで内容を取得
  with open(txt_file_path, "r", encoding="utf-8") as f:
      txt_data = f.read()

  with open(txt_file_path_2, "r", encoding="utf-8") as f:
      txt_data_2 = f.read()

  # 差異を別ファイルに出力
  differ = difflib.Differ()
  diff = differ.compare(txt_data.splitlines(), txt_data_2.splitlines())

  output_file_path = os.path.join(output_dir, output_file_name)
  with open(output_file_path, "w", encoding="utf-8") as f:
      f.write("\n".join(diff))

  print(f"2つのHTMLテキストデータの差異を{output_file_path}に保存しました")
